# Registration Form

Coming soon...

Hook back over to slash register. This is something we will work on in our last security tutorial. We have a functional registration form, but we kind of cheated. Move over and find sources, controller security controller, and find the register action. You can kinda tell by looking at this that this is not using the form framer. We're just manually handling the re the post data and in the template 

in templates, security registered at h and m, it's just a normal html form. Now, first thing I will say is even if you're used this symphony form of component, you don't need to use this symphony form component for every single form. This registration form actually works fairly well as it is, however it is missing. One thing that you do want to make sure you have all of your forms and that's CSRF protection. We'll talk a little bit more about that later, but when he used the symphony form component, you get CSRF protection absolutely for free and so a lot of times that's enough for me to want to use the sinful informed component. So let's refactor this code here to use the form component. Now remember, step one for form is to create a form class like we did with article form type. That's easy enough, but to be even lazier, we can use the make form command. Let's call her form type, user registration form type. And this will ask, ask you if you want this form bounded to a class because you remembered that's optional. We do want to three bound to the user class. Awesome. So accredited one file for us. Move over and open up that file. 

Nice. So it's at the data class to our user class and it even looked at the properties for our user class and prefilled in the fields here. Now of course we don't want roles do you modify bowl? We're not gonna. We're not going to make people type in their twitter username to register. And also first name is something that we won't put on there. We just have these two fields, email and password. All right, next step. Step two is to go into our controller and use that form. So I'll remove my to do insight form equals this Arrow create form and all pass that user registration form type colon, colon class will lead the second argument optional because there's no, we're not editing and user. We're creating a new user, Ben, for the if statement, if up actually before they have statement form, Arrow handle request request and that in the if statement, we can now say if form Arrow is submitted and an form Arrow is valid, 

now instead of creating our user object directly, we can say user equals form Arrow, get data and I'll add some inland documentation there so that Petri storm knows that this is a user object. This one we don't need to set the email directly anymore. That will be sent automatically from the form. I'm going to remove the first name, which was always a hack. We'll fix that in a second and then we do need to set the password. We do need to encode the password, but now the plain, the plain text password will be stored on user arrow. Get Password. Now that is a little weird because we're storing the plain text password on the password field and then a moment later we're encoding that in setting it back on the same property. I want to talk more about that in a second because I don't like that setup, but first down below for our template. Now they have a form object. Let's pass a new registration form set to form. I don't remember where you can always call, create view. Awesome. Then over in our template we can simplify things. I'll remove my to do here and then we can use our same form functions as before. Remember those are form underscore start registration form and form underscore end registration form. Then for all the fields it's form underscore widget registration form, and then we do need our submit button. We already worked on that before it, so I'll go down here and I will steal that button 

and move it up here. Perfect. Now just for now, I want to keep our old form as reference, so I'm going to comment out that form code. Then I'll remove my old comment that I'm actually going to comment out this entire form. We'll keep it for a little bit for reference and we're going to replace with the same form rendering code we had before which was form underscore start registration form, form underscore end registration for them and for the fields form underscore widget registration form for our button. We already worked on that. So I'll go down and steal that button from our previous form and then we will paste that in. Alright, perfect. Let's head over and refresh. 

Okay. It works but it looks terrible and that's because our old form code, even though it's using bootstrap and we're using the bootstrap thing, this was pretty customized. Bootstrap. So that's something we're going to talk about how we can style this form to look the way it looked before, but for the most part it looks like it works. Now, before we read, we, we actually travis and register. If you open your user entity class, we originally made the first name field not knowable. So if you don't see nullable equals true. That means that it's required and the database. Well, I want to allow users to register without their first name, so I'm going to change this to noble equals true. Then of course that means that we need to go over and run bin Console, make colon migration, move back, check out that new file and Yup, it looks perfect. Just changing that first name so I'll move back over and run. Bin Console doctrine. Migrations migrate. Excellent. So let's try out our form finally or register as Jordy adds the enterprise that or can we. Right. Can you show jody's picture but password engage, hit enter and nice. We got it and we are even logged in as Jordan. 

Not to be confused with not being used with Jordy. All right, so head back to slash register. 

Okay. Because 

as I mentioned, there is one thing that's bothering me and I mentioned the fact that if you look at our user registration form type, the plain password is actually set on a password field, which means when we submit that the form component calls set password and actually sets that on our password field, but the password field is meant to be an encoded password. And of course before we save it, we do call user get password to get that plain text password and then we encode it and set up back on that field. So ultimately it saves in the database as an encoded password. But I don't like doing this. I don't like ever setting the plain text password on a password on a field that could be persisted. So go to our user registration form type and we're going to change this to plain password. And I'll put a little comment above here about why we're doing this. Now, of course this is going to be a problem if we go over. Now you try to register with the different user. It's going to blow up neither the property plain password nor one of the methods. Get Plain Password has plain password, blah blah blah, um, has access on the user. And we know why this is happening. I mentioned earlier when you make a field in your form called email, 

then the form system, we'll use the get email 

method to read data off of the user object. And when we submit these set email method to put data back on, so we're effectively saying an error here that says, look, you don't have a get plain password and a set plain password properties or a methods. So there are two ways to fix this. First, we could actually create a plain password property on our entity, make it not persisted, so don't put an arm slash column on it and then create a good plain password and a set plain password method. Or we can mark this field to not be mapped. Check this out. I'm gonna past knows the second argument so it keeps guessing the field for now though, in a second we're going to turn that into a password field and then we're going to say mapped false. What that does is, and now says that I want to have a field called plain password on my form just like before, but now it should not get or set this data back onto our user object. So of course the question then is a, if it's not setting the data on the user, how do we get the data after all? That's the user objects, what we get back from the form system, so where will that plain password data live and your controller dd form left square bracket, plain password Arrow, get data, 

then move over, refresh and Oh, I get this. Form snack contain extra fields. That's because I never fully refreshed the new form after renaming my password field. So we were actually still submitting the old password field and southern new ones. So let's try that again. This time. Yes, it hits our DI statement. So here's the cool thing about the form system. There's a form object on top, but then each individual field is it's for own form object. So this form Lusko back plain password is its own form object and you can ask individually for its data which will be that plain text password. This is a super powerful way to handle a situations where you sometimes have a field that you need in your form, but it doesn't really map cleanly to something on your entity. So we can copy this, remove the DD and then down below, use that instead on our field. Now, before we try this, one last thing I do want to change, is that our. Actually No. So let's move back over. Refresh and this time nice it submits perfectly. All right, so go back to register one last time before I move on. One thing I do want to fix is the fastest path that the plan tax. The password field is actually plain text. 

So go back to your form type and obviously even though, um, the form system has no idea what type of field plain password is. It's not even a property on our entities, so it can't really do any type of form guessing, so it just assumes it's a text type. So change this to password type colon, colon class. Nothing will change with the way it's submitted, but it's now going to render as a proper pasture field. Perfect. Next, let's talk about adding form validation to this, which is going to be a little bit special because we need to validate that the user is unique in the database, which is a special constraint and we also need to apply validation to for the first time to a field that's actually not actually part of our entity class.