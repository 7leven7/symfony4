# Many To Many Save Join

Coming soon...

Now that we have the article in the tag related, we can see that the way this relationship works is via this joint table, so the question is how can we insert new records into that joined table? How can I relate to articles to text? The answer is the exact same way we've been doing with our other relationship, so first opened base fixture and at the bottom I'm going to paste in a new protective function called get random references, so we already have and get random reference where it'll give you one reference. This is just the same thing, but you can pass a class name and you can tell it to give me back five of those objects. They may or may not be unique. This isn't a perfect function, but that's the idea. Next in article fixtures, we're going to set that relationship, which means that we need to make sure that the tag fixtures loaded first so that here we can use references to those tags to join to the article, so this means that we need to go up to the top and implement the pendant fixture interface. I'll go to the code, generate menu or command n go to implement methods and fill and get dependencies. I'll add to that and we need the tag fixture class to get perfect. 

All right, so now up inside of our method, the first thing I'm going to do is actually get to tag objects. Say Tags equals this Arrow, get random references past that tag colon, colon class, and then we'll get, we'll say this number, this Arrow faker error number between zero and five. So we're saying give me between zero and five random tag objects and just to make sure you can see that those are tagged objects. Let's dump tags and die and then go to our terminal and run doctrine fixtures. Load. 

Yeah, 

perfect. So you can see those are tag objects by the way, sometimes you'll see your class name prefixed with this proxies thing. When you see that even nor it. This is an object that is wrapping your tag object and you'll almost never noticed that that's happening in. The reason this happens is, is to assist with doctorands lazy loading, where it lays it lowe's data across relationships, proxies or the magic that make that happen, and you'll also notice that the data appears to be no, that's not actually true. As soon as you referenced some data on that Tag, then it will query and actually fill in that data. In fact, to prove that, let's for each over tags as tag and I'm just going to call 

OK, 

I'll put a little inline documentation up here to say that this is going to be an array of tags here I'm just gonna. Say Tag Arrow, get name, which I know is going to look weird. I'm not even going to use that, but just by calling, getting named, that will be enough to trigger doctrine to go and reference in to go and get that tags object. Then below all dump it and die. So before it looked like we had a tag object with no data in it, but it turns out that as soon as you actually reference a date on it, invisibly behind the scenes, it goes and actually fetches that data. So now we can see it there. So long way of saying don't worry too much about the proxies, they wrap our object, but they don't do anything to it. So the point is here we have an array of tag objects to relate those to an article. We're literally gonna say article, Arrow, add tag tag. There's no article set tags method, but if you wanted to you can add one and that's it. Move back over, reload the fixtures and no errors. Now let's run bin Console doctrine query [inaudible] sql. I'm going to select star from tag and you can see we 10 to tags in there with various names. Now let's search for select star from article underscore tag. Remember that is the name of our joined table. 

Yeah, 

feel for that. Check this out. Twenty four results. So every time we were really an article to tag and saved doctrine manages inserting that record for us. That feels a little bit magic because all we need to do is just that data in it actually is doing. Inserting things behind the scenes, removing tags from articles works the same way. There is an article Arrow remove tag method, and if you ever called this and this, if we ever, if you ever called this, when you use remove tag, if that row already exists in the database, it will actually delete that row in the database for you. So all we need to do is worry about relating article objects to tag objects and it takes care of inserting and deleting all of the rows in that automatically. So let's use this, open up your in your templates directory. Open up article showed that html twig on the article show page. We're going to put the tags out right under the article title, so scroll down a little bit. I'll copy the span for the heart counts, and here we're just going loop over those. We'll say for tag in article, that texts usually helper method there and for inside, 

yeah, 

I'll create a little badge. It will say curly curly tag that name. 

That's it. Go back refreshed 

and we've got it. Well there's only one time. This one that's not very interesting. Let's go back and find a different one. There you go. For different tasks. 

Yeah, yeah, 

that's actually a repeat this on the home page will list the tags right under the title here, so I'm going to copy that for loop and then we'll go into our homepage dot h, so that twig down here when we're printing things out, let's add apr and then I'll paste that. I'm going to wrap it in a small tag so it's not so big and change it to badge light. 

OK, 

but it's the same thing. We have an article variable, so we're going through tags in article since this is a tag object or printing tag name. Notice right now there are eight queries on this page when I refresh that goes up to 15 and once again we're dealing with an n plus one problem, so I'm going to click to view those queries and you'll see they're mixed in here, but you'll see a bunch of queries that are selecting from a tag using the inner join to find only tags for one specific article. Basically every time we referenced the tax for an article, it makes these same querie over and over and over again for a different article ideas. So again, this is probably not something that we need to worry about, but if we want to we can just change the query. Wonder we queried for all of our articles, we could join over to the tags and fetch the data right then. So let's do that so we can see what that looks like. OK. So open your article controller and find homepage. So right now we're using articles equals repository Arrow find all published ordered by newest. So let's go into our article repository class 

and there is our method. You see we're finding the article objects, but we're not doing any special joining or anything like that. So let's join us first. Joined over to tax. And if you think about it, this is a little bit weird because in reality we would need in the database, we would need to join twice. We need to join to the need to. 

Yeah, 

left join to the article underscore tags table and then we would need to inner join from the article tags over to the tag so that we can fetch it's data. This is where the many to many relationship really helps you. You don't even think about that join table, you pretend like it does not exist, so we just say left, join on a dot tags 

and then we'll say t as the reference, since we're clearing from the article class or we can just basically refer to this tags property in it knows this is a many to many relationship so it knows how to join all the way over to attack. Then of course, to get the data we need to do add, select t and that's it. So I'll move over here, refresh 15 queries, go back down to eight and if you check the queries out, it's actually pretty awesome. The first querie grabs everything from article and grabs everything from TAC, the slightest from article, but it left joins over to article tag. 

OK? Yeah. 

And then it left joins again over to tax. So it takes care of both of those joins for us automatically, which is pretty nuts. Now there's one last thing that I want to talk about with many to many relationships and it's just a word of warning. Suppose I wanted to start recording a date of when an article was given attack. Well, Huh? Kind of can't do that. We could record the date that a tag was created and we can record the day that the article is created, but we can't record the date where the article was linked. The tag and the reason is that what data would need to live in this article underscore tag table. We would want a third column here called created at when it used a many relationship. The join table will always only have those two fields on it. You can't add any more columns to your joined table, so before you set up a many to many relationship, you need to ask yourself if you will ever need to store additional metadata about the relationship on that joined table, like a creative at date. 

If you do, if there's even one extra piece of data that you want to store on the table, then it's no longer a many to many relationship. Nope. Instead, what you should do is actually generate an article tag entity. So here you'd Article Tag and you'd actually have another entity called article tack in that Article Tag entity would have a many to one relationship to article and a many to one relationship to tack. This would effectively give you the exact same structure in the database. You'd have an article tag table, the article tag entity, and they would have to foreign keys to article because the article table into the tag table, but now that you have an article tagged entity, you can add whatever other relationships you want. So even when you think you want a many to many relationship, there's actually a pretty good chance that you actually need is to generate a new entity and create too many to one relationships. You can always fix this later to have that set up, but it's easier if you get it right. Initially. Our guys, you are now doctrine pros. Yes you can. You can learn about creating more complex queries and we have to worry about that and there are other cool features that exist in doctrine that you'll find a little by little, but you have all of the fundamentally important stuff. So go out there and really unleash yourself to build something amazing. All right guys, see you next time.