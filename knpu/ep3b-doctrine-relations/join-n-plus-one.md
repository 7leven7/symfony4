# Join N Plus One

Coming soon...

Here's our next mission right now, our search is on the comments content in the comments author name, but I would also like to be able to search the actual article. So if I search for Bacon here, I should find the y asteroids. Tastes like Bacon. 

Yeah, 

message by the way, fun little feature in Twig. You'll notice that for getting no results back here, it doesn't look very good inside of index that each time a twig on the four, you can actually do an else at the end. This is what will be printed if there are no results. So we can do a little td call span. Equals four class equals texts center. No comments found so no comments found. So free fresh now. 

OK, 

it works. 

Oh, except it's not centered because this should be texts center. Refresh. Anyways, we want to search the article, so if you think about this in my sql land, if you want to have a queer that includes where the where clause references some data from another table. The first thing we need to do is join over to that table. In this case, we want to join from common to articles so we can do an inner join, join over, joins our awesome indoctrine. We can just say inner join and then say see dot article a first time you see that. That might blow your mind a little bit. That is all we need when we say see that article were actually referencing the article property, so all we need to say is we want to join across this relationship and then it knows exactly how to do that because this relationship is already set up. The second argument a is going to be the AOB is for the article, so inner join article as a. 

Now if we don't do it, if we didn't do nothing else right now that of course it's not going to change anything, but I want to show you the queary at the bottom, so I'll click to look at the query and if click to view the format so you can see it's selecting from comment and it has the inner join on article. It's not selecting any article data. It's only selecting common data and we're not using the article in our ware clause, but we do now have that joint thanks to that anywhere inside of our queries, we can now reference the article table by using a so inside of our and where we can say or a dot title like term and when we moved back and refresh, it works instantly. Once again, I'll show you the query here and this time you can see our inner join, but just like you'd expect down the bottom there is an or for the for the article title, like our search term. 

You'll also notice that we still have a ton of queries. We have seven queries were still suffering from the n plus one problem specifically as we loop over our rows, every time it finds a new article it needs to go and query for that article is data. That's interesting because if you think about it right now, if you look back at it, we are joining over to article so it's almost seems a little unnecessary that we would then need to query for all the articles. Shouldn't we already have the article data from this first querie? The answer is no, or at least not yet. You'll notice in this queer, we're still only selecting the fields from comment, so even though we're joining over to article, we're only using that in our aware clause. We're not fetching the articles data, so later when we start referencing fields on the article, as it were looping over our table doctor needs to fetch that article data at that point, which is how we get these extra six queries, so if you want to solve the n plus one problem here is how now in common repository now that we have are join at another line called Arrow add. 

Select A. Normally when you create a querybuilder into repository, it's selecting only from c, so basically select every field from seat by saying, add, select a. we're saying, I also wants you to select all of the fields from article. If you go back and refresh, it still works exactly the same except check it out. We're down to one querie. If you view the queary, you can see all the fields from seed and then it selects all the fields from article as well. 

Now, one thing about this is that even though we're selecting the comment feels and the article fields, you'll notice that our page still works. What's important here is that even though we're now selecting the data from article, our methods still returns, comments, comment objects. It does not return article objects. That's because we created the query builder on comment, so no matter what we do, it's going to return comment objects by selecting the article data. That just means that doctrine is going to take that data and store it in the background for later if it needs it, but this does not affect the return value of our method. That's different than queering because of course, when you queries for something and select more fields, you're going to get a different result set back. That's one thing to keep in mind when you're doing this with doctrine.