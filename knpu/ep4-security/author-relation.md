# Author Relation

Coming soon...

If you look in the homepage, you can see that every article has an author, but when we originally set up the system, if you look inside article, 

the author is just a string field and that's because we didn't know how to handle the database relationships correctly. What I want to do now is replaced this author string property with a proper relation to our user entity, so every article will be created by a specific user. The reason we're doing this is it's going to lead us down to some very interesting access control problems with being able to control who is allowed to edit each individual article, but first let's just worry about the relationship stuff, so to remove first, let's remove the author property entirely. Also find the getter and setter methods and we will remove those. How about a bin Console? Now, run a make a migration to remove that column. If this were on production, you might need to be a little bit more careful to make sure you didn't lose that data. If you needed it in the migrations directory, I'll open up the new migration and yep, alter table, article drop author. Great. Next, let's go back and let's run make entity. Let's read ad that article property, the other property, but as a relationship, so let's update the article on Steve. We're going to add a new property called author will make it a relationship. This is going to be a relationship to our user entity. Now this is going to be another many to one relationship because each article has one user in each user can have many articles, so many to one. 

The other author property should not be knowable and this should be required in the database and we'll say yes to mapping the other side of the relationship and I'll say no to orphan removal, but that's not important right now. Then I'll enter to finish. Then once again, run bin Console. Make Colon migration. 

Oh, 

and once again, look over and oh, of course you probably saw I made a mistake there. You can say it's adding author Id, but dropping author. That was my mistake. Delete that migration file because I free after I generated the initial migration file, I forgot to migrate. Well, migrate that will drop that author, original author property. Now we'll run. Make migration. Now we'll clear and ron make migration again. 

Gosh darn it. 

Move over and okay, this looks better. Just adding the author ID and the foreign key constraints on that. I'll close out those migrations and once again, run bin Counsel Doctrine Migrations Migrate. Whoa. When you can see this actually explodes, this isn't one of those tricky migrations where because we made the new column required, it actually fails to add the foreign key in the migration. If this were, if our application we're already deployed to production, well, we'd actually need to do is actually first make the property knowable, true, generate the migration, so that's allowed to be no. Then run some script or a query to set up the author for all the existing articles. Then changes this dental legal spouse and generate another migration. So three different steps to do that because this isn't on production yet. 

Yeah, 

we know when we first deployed, our database is going to be empty and it's not going to have this problem, so we're not going to do is actually run doctrine Schema, dropped dash, dash, dash database, Dash, dash force. That's a fancy way of actually dropping every table in the database. Then I'm going to rerun all of my aggressions to make sure that they are working. Okay, cool. And you can see it works that time because there weren't any articles in the database, so now we do need to go into our article fixtures class though. 

Okay. 

It makes sure we update the code in here. Set author. His strength thing is not going to work anymore. Well, we need to do is actually relate this to one of the users that's created in user fixture. Remember we have two groups, these main users and these admin users. I'm going to allow normal people to create a article, so I'm going to relate it to one of these main users. To do that, we can save this Arrow, get random reference and pass it main underscoring users that will randomly give us one of those elements and then on the top of the class I can remove this old static property. All right, let's try that. Move over. Run Bin Console doctrine, fixtures, load and it works, but only luckily. Notice that use your fixture happened to run before article fixture. 

We need that to happen now that these are dependent on each other but down and get dependencies. I actually want you to add user fixture, colon, colon, class, that will make sure that the user fixtures always run before article fixture. Whereas right now there wasn't guaranteed yet. Do you want to? You can try it again and you shouldn't see it will all load in that same order, but now it's a guaranteed. All right, so our articles now proper user relationships, but we haven't updated anything else in our code. And if refers to the home page, now you get a big explosion and exception has been thrown. Rendering the template catchable fatal error objects proxies, APP entity user cannot be converted to strength. So two important things here, whenever you see this proxies thing, this isn't internal object as wrapping your entity, ignore it. I want you to pretend like this just says that our user could not be converted to string. This part of the article makes sense because in our template we're just friending article that author that used to be a string, but that's now a user object. So we could go change this to article that author dot first name or we can go into our user class and add a two string method. Public function underscore underscore two string. 

That's what return this arrow. Get up first name. Soon as we do that. Nice. It works perfectly. Alright, so what I really want to talk about is I want to start talking about, uh, adding an admin section where you can edit articles. So we already have an article admin controller though. There's only one end point and it just has a di statement in it right now. Hello, this, let's create another public function called edits. I love this. I'm going to put the normal route and we'll have the you where I'll be slash admin slash article slash the idea of the article slash edit. I won't give it any name yet. Down here we can actually say article article. 

Yeah, 

and Cynthia will use the ID, the query for that specific article and inside just to see if this is working. Let's do a DD on article. Now. You'll remember that this entire controller protected by role admin article right now, so only avid users can see it. To get a valid id. I'm actually going to go over my database run doctrine query sql, select star from article and it looks like right now I can use the ID 20. Perfect, so let's go to slash admin slash article slash 20 slash edits to the login page. If you've got an to access, I just go log into somebody else and we'll say admin to have the space for an icon, password engage 

and her. Perfect. We are bumped back to that page. Now here's where things get interesting. I do want admin users to be able to access this page, but I also want the author of this article to be able to edit it too. The problem is if the author is just a normal user, they're not going to have role admin article and I don't want to give them role admin article because I don't want them to be able to create new. Maybe I don't want them to do other stuff like create new articles or delete articles, so for the first time our access control rules are more complex. We need to be able to allow admin users to edit this article or the owner of the article. The permissions are different for each article. We're going to solve that next with a great system called voters.